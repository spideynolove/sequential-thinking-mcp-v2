from typing import Optional, List, Dict, Any
from datetime import datetime
import importlib.metadata
import os
import json
from pathlib import Path
from models import (
    UnifiedSession, Memory, Thought, Branch, 
    ArchitectureDecision, PackageInfo, SessionType
)


class UnifiedSessionManager:
    def __init__(self, memory_bank_path: str = "memory-bank"):
        self.memory_bank_path = Path(memory_bank_path)
        self.sessions_dir = self.memory_bank_path / "sessions"
        self.memories_dir = self.memory_bank_path / "memories"
        self.patterns_dir = self.memory_bank_path / "patterns"
        self.index_file = self.memory_bank_path / "index.md"
        
        self.current_session: Optional[UnifiedSession] = None
        self._ensure_directories()
        self._load_last_active_session()
    
    def _ensure_directories(self):
        """Ensure all required directories exist"""
        self.memory_bank_path.mkdir(exist_ok=True)
        self.sessions_dir.mkdir(exist_ok=True)
        self.memories_dir.mkdir(exist_ok=True)
        self.patterns_dir.mkdir(exist_ok=True)
        
        if not self.index_file.exists():
            self._create_index_file()
    
    def _create_index_file(self):
        """Create initial index.md file"""
        content = "# Session Registry\n\n## Active Sessions\n\n## Archived Sessions\n\n## Memory Collections\n\n## Code Patterns\n\n---\n*Updated: Generated by Sequential Thinking MCP v2*"
        self.index_file.write_text(content)
    
    def start_session(
        self,
        problem: str,
        success_criteria: str,
        constraints: str = "",
        session_type: str = "general",
        codebase_context: str = "",
        package_exploration_required: bool = True
    ) -> str:
        """Unified session creation method"""
        session_type_enum = SessionType.CODING if session_type == "coding" else SessionType.GENERAL
        
        session = UnifiedSession(
            problem=problem,
            success_criteria=success_criteria,
            constraints=constraints,
            session_type=session_type_enum,
            codebase_context=codebase_context,
            package_exploration_required=package_exploration_required
        )
        
        session_id = self._save_session_to_file(session)
        self.current_session = session
        
        if package_exploration_required and session_type == "coding":
            self.explore_packages(problem)
        
        return session_id
    
    def _save_session_to_file(self, session: UnifiedSession) -> str:
        """Save session to markdown file"""
        session_file = self.sessions_dir / f"{session.id}.md"
        
        content = f"""# {session.problem}

**Session ID:** {session.id}
**Type:** {session.session_type.value}
**Created:** {session.created_at.isoformat()}
**Updated:** {session.updated_at.isoformat()}

## Problem Statement
{session.problem}

## Success Criteria
{session.success_criteria}

## Constraints
{session.constraints}

## Codebase Context
{session.codebase_context}

## Thoughts

## Memories

## Architecture Decisions

## Discovered Packages

---
*Session data stored in markdown format*
"""
        session_file.write_text(content)
        self._update_index_with_session(session)
        return session.id
    
    def _update_index_with_session(self, session: UnifiedSession):
        """Update index.md with new session"""
        # Simple index update - in production this could be more sophisticated
        pass
    
    def add_thought(
        self,
        content: str,
        branch_id: str = "",
        confidence: float = 0.8,
        dependencies: str = "",
        explore_packages: bool = False
    ) -> str:
        """Add a thought to the current session"""
        if not self.current_session:
            raise ValueError("No active session")
        
        thought = Thought(
            session_id=self.current_session.id,
            branch_id=branch_id,
            content=content,
            confidence=confidence,
            dependencies=dependencies.split(",") if dependencies else [],
            explore_packages=explore_packages
        )
        
        if explore_packages and self.current_session.session_type == SessionType.CODING:
            thought.suggested_packages = self._suggest_packages(content)
        
        self.current_session.thoughts.append(thought)
        self._save_session_to_file(self.current_session)
        return thought.id
    
    
    def create_branch(self, name: str, from_thought: str, purpose: str) -> str:
        """Create a new branch for alternative reasoning"""
        if not self.current_session:
            raise ValueError("No active session")
        
        branch = Branch(
            name=name,
            purpose=purpose,
            session_id=self.current_session.id,
            from_thought_id=from_thought
        )
        
        self.current_session.branches.append(branch)
        self._save_session_to_file(self.current_session)
        return branch.id
    
    def merge_branch(self, branch_id: str, target_thought: str = "") -> str:
        """Merge a branch back into main reasoning"""
        if not self.current_session:
            raise ValueError("No active session")
        
        for branch in self.current_session.branches:
            if branch.id == branch_id:
                if target_thought:
                    for thought in self.current_session.thoughts:
                        if thought.id == target_thought:
                            thought.content += f"\n[Merged from {branch.name}]"
                            break
                self._save_session_to_file(self.current_session)
                return branch_id
        
        raise ValueError(f"Branch {branch_id} not found")
    
    def store_memory(
        self,
        content: str,
        confidence: float = 0.8,
        code_snippet: str = "",
        language: str = "",
        pattern_type: str = "",
        tags: str = ""
    ) -> str:
        """Store a memory with code snippets and patterns"""
        if not self.current_session:
            raise ValueError("No active session")
        
        memory = Memory(
            session_id=self.current_session.id,
            content=content,
            confidence=confidence,
            code_snippet=code_snippet,
            language=language,
            pattern_type=pattern_type,
            tags=tags.split(",") if tags else []
        )
        
        self.current_session.memories.append(memory)
        self._save_memory_to_file(memory)
        self._save_session_to_file(self.current_session)
        return memory.id
    
    def _save_memory_to_file(self, memory: Memory):
        """Save individual memory to file"""
        memory_file = self.memories_dir / f"{memory.id}.md"
        
        content = f"""# {memory.content[:50]}...

**Memory ID:** {memory.id}
**Session ID:** {memory.session_id}
**Created:** {memory.created_at.isoformat()}
**Updated:** {memory.updated_at.isoformat()}
**Confidence:** {memory.confidence}

## Content
{memory.content}

## Code Snippet
```{memory.language}
{memory.code_snippet}
```

## Pattern Type
{memory.pattern_type}

## Tags
{', '.join(memory.tags)}

---
*Memory stored in markdown format*
"""
        memory_file.write_text(content)
    
    def query_memories(self, tags: str = "", content_contains: str = "") -> List[Dict[str, Any]]:
        """Search memories by tags or content"""
        if not self.current_session:
            return []
        
        filtered_memories = []
        for memory in self.current_session.memories:
            if tags:
                tag_list = [t.strip() for t in tags.split(",")]
                if not any(tag in memory.tags for tag in tag_list):
                    continue
            
            if content_contains:
                if content_contains.lower() not in memory.content.lower():
                    continue
            
            filtered_memories.append({
                "id": memory.id,
                "content": memory.content,
                "tags": memory.tags,
                "confidence": memory.confidence,
                "pattern_type": memory.pattern_type,
                "language": memory.language
            })
        
        return filtered_memories
    
    def explore_packages(self, task_description: str, language: str = "python") -> List[str]:
        """Explore packages for given task"""
        if not self.current_session:
            raise ValueError("No active session")
        
        installed_packages = []
        try:
            for dist in importlib.metadata.distributions():
                package_name = dist.metadata['name']
                relevance_score = self._calculate_relevance(package_name, task_description)
                
                if relevance_score > 0.3:
                    package = PackageInfo(
                        name=package_name,
                        version=dist.version,
                        description=f"Installed package: {package_name}",
                        relevance_score=relevance_score,
                        installation_status="installed",
                        session_id=self.current_session.id
                    )
                    
                    self.current_session.discovered_packages.append(package)
                    installed_packages.append(package_name)
        except Exception:
            pass
        
        self._save_session_to_file(self.current_session)
        return installed_packages
    
    def record_decision(
        self,
        decision_title: str,
        context: str,
        options_considered: str,
        chosen_option: str,
        rationale: str,
        consequences: str,
        package_dependencies: str = ""
    ) -> str:
        """Record an architecture decision with context"""
        if not self.current_session:
            raise ValueError("No active session")
        
        decision = ArchitectureDecision(
            session_id=self.current_session.id,
            decision_title=decision_title,
            context=context,
            options_considered=options_considered,
            chosen_option=chosen_option,
            rationale=rationale,
            consequences=consequences,
            package_dependencies=package_dependencies.split(",") if package_dependencies else []
        )
        
        self.current_session.architecture_decisions.append(decision)
        self._save_session_to_file(self.current_session)
        return decision.id
    
    def analyze_session(self) -> Dict[str, Any]:
        """Analyze current session completeness and insights"""
        if not self.current_session:
            return {"error": "No active session"}
        
        return {
            "session_id": self.current_session.id,
            "session_type": self.current_session.session_type.value,
            "total_thoughts": len(self.current_session.thoughts),
            "total_memories": len(self.current_session.memories),
            "total_branches": len(self.current_session.branches),
            "architecture_decisions": len(self.current_session.architecture_decisions),
            "discovered_packages": len(self.current_session.discovered_packages),
            "created_at": self.current_session.created_at.isoformat(),
            "updated_at": self.current_session.updated_at.isoformat()
        }
    
    def list_sessions(self) -> List[Dict[str, Any]]:
        """List all saved sessions"""
        sessions = []
        try:
            for session_file in self.sessions_dir.glob("*.md"):
                # Simple parsing - in production this could be more sophisticated
                session_id = session_file.stem
                sessions.append({
                    "id": session_id,
                    "file": str(session_file),
                    "created": session_file.stat().st_ctime
                })
        except Exception:
            pass
        
        # Sort by creation time, newest first
        return sorted(sessions, key=lambda x: x["created"], reverse=True)
    
    def load_session(self, session_id: str) -> Dict[str, Any]:
        """Resume a specific session"""
        session_file = self.sessions_dir / f"{session_id}.md"
        
        if not session_file.exists():
            raise ValueError(f"Session {session_id} not found")
        
        # For now, create a basic session object
        # In production, this would parse the markdown file
        session = UnifiedSession()
        session.id = session_id
        self.current_session = session
        
        return {
            "session_id": session_id,
            "status": "loaded",
            "file": str(session_file)
        }
    
    def _suggest_packages(self, content: str) -> List[str]:
        """Suggest relevant packages based on content keywords"""
        suggestions = []
        keywords = {
            "http": ["requests", "httpx", "urllib3"],
            "web": ["flask", "django", "fastapi"],
            "data": ["pandas", "numpy", "sqlite3"],
            "test": ["pytest", "unittest", "mock"],
            "json": ["json", "jsonschema", "pydantic"],
            "async": ["asyncio", "aiohttp", "tornado"]
        }
        
        content_lower = content.lower()
        for keyword, packages in keywords.items():
            if keyword in content_lower:
                suggestions.extend(packages)
        
        return list(set(suggestions))
    
    def _calculate_relevance(self, package_name: str, task_description: str) -> float:
        """Calculate relevance score between package and task"""
        task_lower = task_description.lower()
        package_lower = package_name.lower()
        
        if package_lower in task_lower:
            return 0.8
        
        common_words = set(task_lower.split()) & set(package_lower.split())
        if common_words:
            return 0.5
        
        return 0.1
    
    def _load_last_active_session(self) -> None:
        """Load the most recent session on startup"""
        try:
            sessions = self.list_sessions()
            if sessions:
                # Load the most recent session
                latest_session_id = sessions[0]["id"]
                self.load_session(latest_session_id)
        except Exception:
            pass