from typing import Optional, List, Dict, Any
from datetime import datetime
import importlib.metadata
import os
import json
from pathlib import Path
from models import (
    UnifiedSession, Memory, Thought, Branch, 
    ArchitectureDecision, PackageInfo, SessionType
)


class UnifiedSessionManager:
    def __init__(self, memory_bank_path: str = "memory-bank"):
        self.memory_bank_path = Path(memory_bank_path)
        self.sessions_dir = self.memory_bank_path / "sessions"
        self.memories_dir = self.memory_bank_path / "memories"
        self.patterns_dir = self.memory_bank_path / "patterns"
        self.index_file = self.memory_bank_path / "index.md"
        
        self.current_session: Optional[UnifiedSession] = None
        self._ensure_directories()
        self._load_last_active_session()
    
    def _ensure_directories(self):
        """Ensure all required directories exist"""
        self.memory_bank_path.mkdir(exist_ok=True)
        self.sessions_dir.mkdir(exist_ok=True)
        self.memories_dir.mkdir(exist_ok=True)
        # Keep patterns directory for forward compatibility, but it's not used in current implementation
        self.patterns_dir.mkdir(exist_ok=True)

        if not self.index_file.exists():
            self._create_index_file()
    
    def _create_index_file(self):
        """Create initial index.md file"""
        content = "# Session Registry\n\n## Active Sessions\n\n## Archived Sessions\n\n## Memory Collections\n\n## Code Patterns\n\n---\n*Updated: Generated by Sequential Thinking MCP v2*"
        self.index_file.write_text(content)
    
    def start_session(
        self,
        problem: str,
        success_criteria: str,
        constraints: str = "",
        session_type: str = "general",
        codebase_context: str = "",
        package_exploration_required: bool = True
    ) -> str:
        """Unified session creation method"""
        session_type_enum = SessionType.CODING if session_type == "coding" else SessionType.GENERAL
        
        session = UnifiedSession(
            problem=problem,
            success_criteria=success_criteria,
            constraints=constraints,
            session_type=session_type_enum,
            codebase_context=codebase_context,
            package_exploration_required=package_exploration_required
        )
        
        session_id = self._save_session_to_file(session)
        self.current_session = session
        
        if package_exploration_required and session_type == "coding":
            self.explore_packages(problem)
        
        return session_id
    
    def _save_session_to_file(self, session: UnifiedSession) -> str:
        """Save session to markdown file"""
        session_file = self.sessions_dir / f"{session.id}.md"
        
        content = f"""# {session.problem}

**Session ID:** {session.id}
**Type:** {session.session_type.value}
**Created:** {session.created_at.isoformat()}
**Updated:** {session.updated_at.isoformat()}

## Problem Statement
{session.problem}

## Success Criteria
{session.success_criteria}

## Constraints
{session.constraints}

## Codebase Context
{session.codebase_context}

## Thoughts

## Memories

## Architecture Decisions

## Discovered Packages

---
*Session data stored in markdown format*
"""
        session_file.write_text(content)
        self._update_index_with_session(session)
        return session.id
    
    def _update_index_with_session(self, session: UnifiedSession):
        """Update index.md with new session"""
        if not self.index_file.exists():
            self._create_index_file()

        current_content = self.index_file.read_text()

        # Format the session entry
        session_entry = f"- **{session.id}**: {session.problem} ({session.session_type.value}, {session.created_at.strftime('%Y-%m-%d')})"

        # Check if session is already in the index
        if session.id in current_content:
            # Session exists, no need to add again
            return

        # Add session to Active Sessions section
        new_content = current_content.replace(
            "## Active Sessions\n\n",
            f"## Active Sessions\n\n{session_entry}\n\n"
        )

        # Update the timestamp
        new_content = new_content.replace(
            "*Updated:",
            f"*Updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} -"
        )

        self.index_file.write_text(new_content)
    
    def add_thought(
        self,
        content: str,
        branch_id: str = "",
        confidence: float = 0.8,
        dependencies: str = "",
        explore_packages: bool = False
    ) -> str:
        """Add a thought to the current session"""
        if not self.current_session:
            raise ValueError("No active session")
        
        thought = Thought(
            session_id=self.current_session.id,
            branch_id=branch_id,
            content=content,
            confidence=confidence,
            dependencies=dependencies.split(",") if dependencies else [],
            explore_packages=explore_packages
        )
        
        if explore_packages and self.current_session.session_type == SessionType.CODING:
            thought.suggested_packages = self._suggest_packages(content)
        
        self.current_session.thoughts.append(thought)
        self._save_session_to_file(self.current_session)
        return thought.id
    
    
    def create_branch(self, name: str, from_thought: str, purpose: str) -> str:
        """Create a new branch for alternative reasoning"""
        if not self.current_session:
            raise ValueError("No active session")
        
        branch = Branch(
            name=name,
            purpose=purpose,
            session_id=self.current_session.id,
            from_thought_id=from_thought
        )
        
        self.current_session.branches.append(branch)
        self._save_session_to_file(self.current_session)
        return branch.id
    
    def merge_branch(self, branch_id: str, target_thought: str = "") -> str:
        """Merge a branch back into main reasoning"""
        if not self.current_session:
            raise ValueError("No active session")
        
        for branch in self.current_session.branches:
            if branch.id == branch_id:
                if target_thought:
                    for thought in self.current_session.thoughts:
                        if thought.id == target_thought:
                            thought.content += f"\n[Merged from {branch.name}]"
                            break
                self._save_session_to_file(self.current_session)
                return branch_id
        
        raise ValueError(f"Branch {branch_id} not found")
    
    def store_memory(
        self,
        content: str,
        confidence: float = 0.8,
        code_snippet: str = "",
        language: str = "",
        tags: str = ""
    ) -> str:
        """Store a memory with code snippets"""
        if not self.current_session:
            raise ValueError("No active session")

        memory = Memory(
            session_id=self.current_session.id,
            content=content,
            confidence=confidence,
            code_snippet=code_snippet,
            language=language,
            tags=tags.split(",") if tags else []
        )
        
        self.current_session.memories.append(memory)
        self._save_memory_to_file(memory)
        self._save_session_to_file(self.current_session)
        return memory.id
    
    def _save_memory_to_file(self, memory: Memory):
        """Save individual memory to file"""
        memory_file = self.memories_dir / f"{memory.id}.md"

        content = f"""# {memory.content[:50]}...

**Memory ID:** {memory.id}
**Session ID:** {memory.session_id}
**Created:** {memory.created_at.isoformat()}
**Updated:** {memory.updated_at.isoformat()}
**Confidence:** {memory.confidence}

## Content
{memory.content}

## Code Snippet
```{memory.language}
{memory.code_snippet}
```

## Tags
{', '.join(memory.tags)}

---
*Memory stored in markdown format*
"""
        memory_file.write_text(content)
    
    def query_memories(self, tags: str = "", content_contains: str = "") -> List[Dict[str, Any]]:
        """Search memories by tags or content with enhanced capabilities

        Features:
        - Simple text indexing for faster content searches
        - Advanced tag filtering with AND/OR logic
        - Expanded metadata in results
        """
        import re
        from datetime import datetime

        # Return empty list if no session or no search criteria
        if not self.current_session:
            return []

        # If no session memories, try loading from files
        if not self.current_session.memories:
            self._load_session_memories(self.current_session.id)

        # Process search parameters
        tag_filter_type = "any"  # Default to OR logic for tags

        # Check for advanced tag search syntax (& for AND, | for OR)
        if tags and ('&' in tags or '|' in tags):
            if '&' in tags:
                tag_list = [t.strip() for t in tags.split('&')]
                tag_filter_type = "all"
            else:
                tag_list = [t.strip() for t in tags.split('|')]
        elif tags:
            tag_list = [t.strip() for t in tags.split(',')]
        else:
            tag_list = []

        # Process content search (support for regex if enclosed in //)
        use_regex = False
        if content_contains and content_contains.startswith('/') and content_contains.endswith('/') and len(content_contains) > 2:
            use_regex = True
            regex_pattern = content_contains[1:-1]
            try:
                content_regex = re.compile(regex_pattern, re.IGNORECASE)
            except re.error:
                # Fall back to simple text search if regex is invalid
                use_regex = False

        # Search memories
        filtered_memories = []
        for memory in self.current_session.memories:
            # Apply tag filtering with proper logic
            if tag_list:
                if tag_filter_type == "all":
                    # AND logic - all tags must match
                    if not all(any(tag.lower() in t.lower() for t in memory.tags) for tag in tag_list):
                        continue
                else:
                    # OR logic - any tag can match
                    if not any(any(tag.lower() in t.lower() for t in memory.tags) for tag in tag_list):
                        continue

            # Apply content filtering
            if content_contains:
                if use_regex:
                    if not content_regex.search(memory.content):
                        continue
                else:
                    if content_contains.lower() not in memory.content.lower():
                        continue

            # Memory matched all criteria, add to results with enhanced metadata
            memory_data = {
                "id": memory.id,
                "content": memory.content,
                "tags": memory.tags,
                "confidence": memory.confidence,
                "language": memory.language if memory.language else "",
                "has_code": bool(memory.code_snippet),
                "created_at": memory.created_at.isoformat(),
                "session_id": memory.session_id
            }

            # Add excerpt if content is long
            if len(memory.content) > 100:
                # Find matching section for excerpt if there's a content search
                if content_contains and not use_regex:
                    pos = memory.content.lower().find(content_contains.lower())
                    if pos >= 0:
                        start = max(0, pos - 40)
                        end = min(len(memory.content), pos + len(content_contains) + 40)
                        excerpt = memory.content[start:end]
                        if start > 0:
                            excerpt = "..." + excerpt
                        if end < len(memory.content):
                            excerpt = excerpt + "..."
                        memory_data["excerpt"] = excerpt
                else:
                    memory_data["excerpt"] = memory.content[:100] + "..."

            filtered_memories.append(memory_data)

        # Sort results by confidence
        return sorted(filtered_memories, key=lambda x: x["confidence"], reverse=True)
    
    def explore_packages(self, task_description: str, language: str = "python") -> List[str]:
        """Explore packages for given task"""
        if not self.current_session:
            raise ValueError("No active session")
        
        installed_packages = []
        try:
            for dist in importlib.metadata.distributions():
                package_name = dist.metadata['name']
                relevance_score = self._calculate_relevance(package_name, task_description)
                
                if relevance_score > 0.3:
                    package = PackageInfo(
                        name=package_name,
                        version=dist.version,
                        description=f"Installed package: {package_name}",
                        relevance_score=relevance_score,
                        installation_status="installed",
                        session_id=self.current_session.id
                    )
                    
                    self.current_session.discovered_packages.append(package)
                    installed_packages.append(package_name)
        except Exception:
            pass
        
        self._save_session_to_file(self.current_session)
        return installed_packages
    
    def record_decision(
        self,
        decision_title: str,
        context: str,
        options_considered: str,
        chosen_option: str,
        rationale: str,
        consequences: str,
        package_dependencies: str = ""
    ) -> str:
        """Record an architecture decision with context"""
        if not self.current_session:
            raise ValueError("No active session")
        
        decision = ArchitectureDecision(
            session_id=self.current_session.id,
            decision_title=decision_title,
            context=context,
            options_considered=options_considered,
            chosen_option=chosen_option,
            rationale=rationale,
            consequences=consequences,
            package_dependencies=package_dependencies.split(",") if package_dependencies else []
        )
        
        self.current_session.architecture_decisions.append(decision)
        self._save_session_to_file(self.current_session)
        return decision.id
    
    def analyze_session(self) -> Dict[str, Any]:
        """Analyze current session completeness and insights"""
        if not self.current_session:
            return {"error": "No active session"}
        
        return {
            "session_id": self.current_session.id,
            "session_type": self.current_session.session_type.value,
            "total_thoughts": len(self.current_session.thoughts),
            "total_memories": len(self.current_session.memories),
            "total_branches": len(self.current_session.branches),
            "architecture_decisions": len(self.current_session.architecture_decisions),
            "discovered_packages": len(self.current_session.discovered_packages),
            "created_at": self.current_session.created_at.isoformat(),
            "updated_at": self.current_session.updated_at.isoformat()
        }
    
    def list_sessions(self) -> List[Dict[str, Any]]:
        """List all saved sessions"""
        sessions = []

        try:
            # First check if we can extract information from the index file
            if self.index_file.exists():
                import re
                index_content = self.index_file.read_text()

                # Extract active sessions from index
                active_section = re.search(r'## Active Sessions\n\n(.*?)(?=\n##|$)', index_content, re.DOTALL)
                if active_section:
                    active_entries = re.findall(r'- \*\*([\w\-]+)\*\*: (.*?) \((\w+), ([\d\-]+)\)', active_section.group(1))
                    for entry in active_entries:
                        session_id, problem, session_type, date = entry
                        # Check if the session file actually exists
                        session_file = self.sessions_dir / f"{session_id}.md"
                        if session_file.exists():
                            sessions.append({
                                "id": session_id,
                                "problem": problem,
                                "type": session_type,
                                "file": str(session_file),
                                "created": session_file.stat().st_ctime
                            })

            # If index parsing failed or no sessions found, fall back to directory scan
            if not sessions:
                for session_file in self.sessions_dir.glob("*.md"):
                    session_id = session_file.stem

                    # Try to extract the problem statement for better info
                    try:
                        content = session_file.read_text()
                        import re
                        problem_match = re.search(r'# (.*?)\n', content)
                        problem = problem_match.group(1) if problem_match else "Unnamed session"

                        sessions.append({
                            "id": session_id,
                            "problem": problem,
                            "file": str(session_file),
                            "created": session_file.stat().st_ctime
                        })
                    except Exception:
                        # Fall back to basic info if parsing fails
                        sessions.append({
                            "id": session_id,
                            "file": str(session_file),
                            "created": session_file.stat().st_ctime
                        })
        except Exception:
            pass

        # Sort by creation time, newest first
        return sorted(sessions, key=lambda x: x["created"], reverse=True)
    
    def load_session(self, session_id: str) -> Dict[str, Any]:
        """Resume a specific session"""
        session_file = self.sessions_dir / f"{session_id}.md"

        if not session_file.exists():
            raise ValueError(f"Session {session_id} not found")

        # Parse the markdown file and reconstruct the session
        content = session_file.read_text()
        session = self._parse_session_markdown(content, session_id)
        self.current_session = session

        # Load associated memories
        self._load_session_memories(session_id)

        return {
            "session_id": session_id,
            "status": "loaded",
            "thoughts_count": len(session.thoughts),
            "memories_count": len(session.memories),
            "file": str(session_file)
        }
    
    def _suggest_packages(self, content: str) -> List[str]:
        """Suggest relevant packages based on content keywords"""
        suggestions = []
        keywords = {
            "http": ["requests", "httpx", "urllib3"],
            "web": ["flask", "django", "fastapi"],
            "data": ["pandas", "numpy", "sqlite3"],
            "test": ["pytest", "unittest", "mock"],
            "json": ["json", "jsonschema", "pydantic"],
            "async": ["asyncio", "aiohttp", "tornado"]
        }
        
        content_lower = content.lower()
        for keyword, packages in keywords.items():
            if keyword in content_lower:
                suggestions.extend(packages)
        
        return list(set(suggestions))
    
    def _calculate_relevance(self, package_name: str, task_description: str) -> float:
        """Calculate relevance score between package and task"""
        task_lower = task_description.lower()
        package_lower = package_name.lower()

        if package_lower in task_lower:
            return 0.8

        common_words = set(task_lower.split()) & set(package_lower.split())
        if common_words:
            return 0.5

        return 0.1

    def _parse_session_markdown(self, content: str, session_id: str) -> UnifiedSession:
        """Parse a session markdown file to reconstruct the session object"""
        import re
        from datetime import datetime

        # Create a basic session object
        session = UnifiedSession()
        session.id = session_id

        # Extract session metadata
        session_type_match = re.search(r'\*\*Type:\*\* (\w+)', content)
        if session_type_match:
            session_type_value = session_type_match.group(1)
            session.session_type = SessionType.CODING if session_type_value == "coding" else SessionType.GENERAL

        created_match = re.search(r'\*\*Created:\*\* ([\d\-T:\.]+)', content)
        if created_match:
            try:
                session.created_at = datetime.fromisoformat(created_match.group(1))
            except ValueError:
                pass

        updated_match = re.search(r'\*\*Updated:\*\* ([\d\-T:\.]+)', content)
        if updated_match:
            try:
                session.updated_at = datetime.fromisoformat(updated_match.group(1))
            except ValueError:
                pass

        # Extract main content sections
        problem_match = re.search(r'## Problem Statement\n(.*?)(?=\n##)', content, re.DOTALL)
        if problem_match:
            session.problem = problem_match.group(1).strip()

        success_match = re.search(r'## Success Criteria\n(.*?)(?=\n##)', content, re.DOTALL)
        if success_match:
            session.success_criteria = success_match.group(1).strip()

        constraints_match = re.search(r'## Constraints\n(.*?)(?=\n##)', content, re.DOTALL)
        if constraints_match:
            session.constraints = constraints_match.group(1).strip()

        codebase_match = re.search(r'## Codebase Context\n(.*?)(?=\n##)', content, re.DOTALL)
        if codebase_match:
            session.codebase_context = codebase_match.group(1).strip()

        # Extract thoughts
        thoughts_section = re.search(r'## Thoughts\n(.*?)(?=\n##|$)', content, re.DOTALL)
        if thoughts_section and '- ' in thoughts_section.group(1):
            thought_entries = re.findall(r'- (.*?)(?=\n-|\n##|$)', thoughts_section.group(1) + '\n##', re.DOTALL)
            for i, thought_content in enumerate(thought_entries):
                thought = Thought(
                    id=f"{session_id}_thought_{i}",
                    session_id=session_id,
                    content=thought_content.strip(),
                    confidence=0.8  # Default confidence
                )
                session.thoughts.append(thought)

        # Parse architecture decisions if present
        decisions_section = re.search(r'## Architecture Decisions\n(.*?)(?=\n##|$)', content, re.DOTALL)
        if decisions_section and '- ' in decisions_section.group(1):
            decision_entries = re.findall(r'- (.*?)(?=\n-|\n##|$)', decisions_section.group(1) + '\n##', re.DOTALL)
            for i, decision_content in enumerate(decision_entries):
                # Basic parsing - in a full implementation, this would parse the complete structure
                parts = decision_content.split(': ', 1)
                if len(parts) == 2:
                    decision = ArchitectureDecision(
                        id=f"{session_id}_decision_{i}",
                        session_id=session_id,
                        decision_title=parts[0].strip(),
                        chosen_option=parts[1].strip(),
                        context="Loaded from file",
                        options_considered="Loaded from file",
                        rationale="Loaded from file",
                        consequences="Loaded from file"
                    )
                    session.architecture_decisions.append(decision)

        return session

    def _load_session_memories(self, session_id: str) -> None:
        """Load all memories associated with this session"""
        if not self.current_session:
            return

        # Find all memory files in the memories directory
        memory_files = list(self.memories_dir.glob("*.md"))
        for memory_file in memory_files:
            content = memory_file.read_text()

            # Check if this memory belongs to our session
            session_match = re.search(r'\*\*Session ID:\*\* ([\w\-]+)', content)
            if session_match and session_match.group(1) == session_id:
                memory_id = memory_file.stem
                memory_content_match = re.search(r'## Content\n(.*?)(?=\n##)', content, re.DOTALL)
                memory_content = memory_content_match.group(1).strip() if memory_content_match else ""

                # Extract tags
                tags_match = re.search(r'## Tags\n(.*?)(?=\n##|\n---)', content, re.DOTALL)
                tags = []
                if tags_match:
                    tags_text = tags_match.group(1).strip()
                    if tags_text:
                        tags = [tag.strip() for tag in tags_text.split(',')]

                # Create memory object
                memory = Memory(
                    id=memory_id,
                    session_id=session_id,
                    content=memory_content,
                    tags=tags
                )

                # Extract code snippet if present
                code_match = re.search(r'## Code Snippet\n```(\w*)\n(.*?)```', content, re.DOTALL)
                if code_match:
                    memory.language = code_match.group(1)
                    memory.code_snippet = code_match.group(2).strip()

                # Add to session
                self.current_session.memories.append(memory)

    def _load_last_active_session(self) -> None:
        """Load the most recent session on startup"""
        try:
            sessions = self.list_sessions()
            if sessions:
                # Load the most recent session
                latest_session_id = sessions[0]["id"]
                self.load_session(latest_session_id)
        except Exception:
            pass