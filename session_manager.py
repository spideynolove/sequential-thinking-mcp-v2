from typing import Optional, List, Dict, Any
from datetime import datetime
import importlib.metadata
import re
import logging
from pathlib import Path
from models import (
    UnifiedSession,
    Memory,
    Thought,
    Branch,
    ArchitectureDecision,
    PackageInfo,
    SessionType,
)
from errors import (
    SessionError,
    NoActiveSessionError,
    SessionNotFoundError,
    ValidationError,
    StorageError,
    MemoryError,
    BranchError,
    PackageExplorationError,
)


class UnifiedSessionManager:
    def __init__(self, memory_bank_path: str = "memory-bank"):
        self.logger = logging.getLogger(__name__)
        self.memory_bank_path = Path(memory_bank_path)
        self.sessions_dir = self.memory_bank_path / "sessions"
        self.memories_dir = self.memory_bank_path / "memories"
        self.patterns_dir = self.memory_bank_path / "patterns"
        self.index_file = self.memory_bank_path / "index.md"
        self.current_session: Optional[UnifiedSession] = None

        try:
            self._ensure_directories()
            self._load_last_active_session()
        except Exception as e:
            self.logger.error(f"Failed to initialize session manager: {e}")
            raise StorageError(f"Could not initialize memory bank at {memory_bank_path}: {e}")

    def _ensure_directories(self):
        self.memory_bank_path.mkdir(exist_ok=True)
        self.sessions_dir.mkdir(exist_ok=True)
        self.memories_dir.mkdir(exist_ok=True)
        self.patterns_dir.mkdir(exist_ok=True)
        if not self.index_file.exists():
            self._create_index_file()

    def _create_index_file(self):
        content = "# Session Registry\n\n## Active Sessions\n\n## Archived Sessions\n\n## Memory Collections\n\n## Code Patterns\n\n---\n*Updated: Generated by Sequential Thinking MCP v2*"
        self.index_file.write_text(content)

    def start_session(
        self,
        problem: str,
        success_criteria: str,
        constraints: str = "",
        session_type: str = "general",
        codebase_context: str = "",
        package_exploration_required: bool = True,
    ) -> str:
        session_type_enum = (
            SessionType.CODING if session_type == "coding" else SessionType.GENERAL
        )
        session = UnifiedSession(
            problem=problem,
            success_criteria=success_criteria,
            constraints=constraints,
            session_type=session_type_enum,
            codebase_context=codebase_context,
            package_exploration_required=package_exploration_required,
        )
        session_id = self._save_session_to_file(session)
        self.current_session = session
        if package_exploration_required and session_type == "coding":
            self.explore_packages(problem)
        return session_id

    def _save_session_to_file(self, session: UnifiedSession) -> str:
        session_file = self.sessions_dir / f"{session.id}.md"

        # Build thoughts section
        thoughts_content = ""
        for i, thought in enumerate(session.thoughts, 1):
            branch_info = f" (Branch: {thought.branch_id})" if thought.branch_id else ""
            thoughts_content += f"### Thought {i}{branch_info}\n\n"
            thoughts_content += f"**ID:** {thought.id}\n"
            thoughts_content += f"**Confidence:** {thought.confidence}\n"
            thoughts_content += f"**Created:** {thought.created_at.isoformat()}\n\n"
            thoughts_content += f"{thought.content}\n\n"
            if thought.dependencies:
                thoughts_content += f"**Dependencies:** {', '.join(thought.dependencies)}\n\n"
            if thought.suggested_packages:
                thoughts_content += f"**Suggested Packages:** {', '.join(thought.suggested_packages)}\n\n"
            thoughts_content += "---\n\n"

        # Build memories section
        memories_content = ""
        for memory in session.memories:
            memories_content += f"### {memory.content[:50]}...\n\n"
            memories_content += f"**ID:** {memory.id}\n"
            memories_content += f"**Confidence:** {memory.confidence}\n"
            memories_content += f"**Tags:** {', '.join(memory.tags)}\n\n"
            if memory.code_snippet:
                memories_content += f"**Code:**\n```{memory.language}\n{memory.code_snippet}\n```\n\n"
            memories_content += "---\n\n"

        # Build architecture decisions section
        decisions_content = ""
        for decision in session.architecture_decisions:
            decisions_content += f"### {decision.decision_title}\n\n"
            decisions_content += f"**ID:** {decision.id}\n"
            decisions_content += f"**Context:** {decision.context}\n\n"
            decisions_content += f"**Options Considered:** {decision.options_considered}\n\n"
            decisions_content += f"**Chosen Option:** {decision.chosen_option}\n\n"
            decisions_content += f"**Rationale:** {decision.rationale}\n\n"
            decisions_content += f"**Consequences:** {decision.consequences}\n\n"
            if decision.package_dependencies:
                decisions_content += f"**Package Dependencies:** {', '.join(decision.package_dependencies)}\n\n"
            decisions_content += "---\n\n"

        # Build packages section
        packages_content = ""
        for package in session.discovered_packages:
            packages_content += f"### {package.name} v{package.version}\n\n"
            packages_content += f"**Relevance Score:** {package.relevance_score}\n"
            packages_content += f"**Status:** {package.installation_status}\n"
            if package.api_signatures:
                packages_content += f"**API Signatures:**\n"
                for sig in package.api_signatures:
                    packages_content += f"- `{sig}`\n"
            packages_content += "\n---\n\n"

        content = f"""# {session.problem}

**Session ID:** {session.id}
**Type:** {session.session_type.value}
**Created:** {session.created_at.isoformat()}
**Updated:** {session.updated_at.isoformat()}

## Problem Statement
{session.problem}

## Success Criteria
{session.success_criteria}

## Constraints
{session.constraints}

## Codebase Context
{session.codebase_context}

## Thoughts ({len(session.thoughts)})

{thoughts_content}

## Memories ({len(session.memories)})

{memories_content}

## Architecture Decisions ({len(session.architecture_decisions)})

{decisions_content}

## Discovered Packages ({len(session.discovered_packages)})

{packages_content}

---
*Session data stored in markdown format*
"""

        try:
            session_file.write_text(content)
            self._update_index_with_session(session)
            return session.id
        except Exception as e:
            self.logger.error(f"Failed to save session to file: {e}")
            raise StorageError(f"Could not save session {session.id}: {e}")

    def _update_index_with_session(self, session: UnifiedSession):
        if not self.index_file.exists():
            self._create_index_file()
        current_content = self.index_file.read_text()
        session_entry = f"- **{session.id}**: {session.problem} ({session.session_type.value}, {session.created_at.strftime('%Y-%m-%d')})"
        if session.id in current_content:
            return
        new_content = current_content.replace(
            "## Active Sessions\n\n", f"## Active Sessions\n\n{session_entry}\n\n"
        )
        new_content = new_content.replace(
            "*Updated:", f"*Updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} -"
        )
        self.index_file.write_text(new_content)

    def add_thought(
        self,
        content: str,
        branch_id: str = "",
        confidence: float = 0.8,
        dependencies: str = "",
        explore_packages: bool = False,
    ) -> str:
        if not self.current_session:
            raise NoActiveSessionError("Cannot add thought without an active session")

        try:
            # Validate confidence bounds
            if not (0 <= confidence <= 1):
                raise ValidationError("Thought confidence must be between 0 and 1")

            thought = Thought(
                session_id=self.current_session.id,
                branch_id=branch_id,
                content=content.strip(),
                confidence=confidence,
                dependencies=dependencies,
                explore_packages=explore_packages,
            )

            if explore_packages and self.current_session.session_type == SessionType.CODING:
                try:
                    thought.suggested_packages = self._suggest_packages(content)
                except Exception as e:
                    self.logger.warning(f"Package exploration failed: {e}")
                    thought.suggested_packages = []

            self.current_session.thoughts.append(thought)
            self._save_session_to_file(self.current_session)
            return thought.id

        except ValidationError:
            raise
        except Exception as e:
            self.logger.error(f"Failed to add thought: {e}")
            raise SessionError(f"Could not add thought: {e}")

    def create_branch(self, name: str, from_thought: str, purpose: str) -> str:
        if not self.current_session:
            raise NoActiveSessionError("Cannot create branch without an active session")

        try:
            if not name or not name.strip():
                raise ValidationError("Branch name cannot be empty")

            if not purpose or not purpose.strip():
                raise ValidationError("Branch purpose cannot be empty")

            if not from_thought or not from_thought.strip():
                raise ValidationError("Branch must reference a valid thought ID")

            branch = Branch(
                name=name.strip(),
                purpose=purpose.strip(),
                session_id=self.current_session.id,
                from_thought_id=from_thought.strip(),
            )
            self.current_session.branches.append(branch)
            self._save_session_to_file(self.current_session)
            return branch.id

        except ValidationError:
            raise
        except Exception as e:
            self.logger.error(f"Failed to create branch: {e}")
            raise BranchError(f"Could not create branch '{name}': {e}")

    def merge_branch(self, branch_id: str, target_thought: str = "") -> str:
        if not self.current_session:
            raise NoActiveSessionError("Cannot merge branch without an active session")

        try:
            if not branch_id or not branch_id.strip():
                raise ValidationError("Branch ID cannot be empty")

            branch_found = False
            for branch in self.current_session.branches:
                if branch.id == branch_id:
                    branch_found = True
                    if target_thought:
                        thought_found = False
                        for thought in self.current_session.thoughts:
                            if thought.id == target_thought:
                                thought.content += f"\n[Merged from {branch.name}]"
                                thought_found = True
                                break
                        if not thought_found:
                            raise ValidationError(f"Target thought '{target_thought}' not found")
                    self._save_session_to_file(self.current_session)
                    return branch_id

            if not branch_found:
                raise BranchError(f"Branch '{branch_id}' not found")

        except (ValidationError, BranchError):
            raise
        except Exception as e:
            self.logger.error(f"Failed to merge branch: {e}")
            raise BranchError(f"Could not merge branch '{branch_id}': {e}")

    def store_memory(
        self,
        content: str,
        confidence: float = 0.8,
        code_snippet: str = "",
        language: str = "",
        tags: str = "",
    ) -> str:
        if not self.current_session:
            raise ValueError("No active session")
        memory = Memory(
            session_id=self.current_session.id,
            content=content,
            confidence=confidence,
            code_snippet=code_snippet,
            language=language,
            tags=tags.split(",") if tags else [],
        )
        self.current_session.memories.append(memory)
        self._save_memory_to_file(memory)
        self._save_session_to_file(self.current_session)
        return memory.id

    def _save_memory_to_file(self, memory: Memory):
        memory_file = self.memories_dir / f"{memory.id}.md"
        content = f"""# {memory.content[:50]}...

**Memory ID:** {memory.id}
**Session ID:** {memory.session_id}
**Created:** {memory.created_at.isoformat()}
**Updated:** {memory.updated_at.isoformat()}
**Confidence:** {memory.confidence}

## Content
{memory.content}

## Code Snippet
```{memory.language}
{memory.code_snippet}
```

## Tags
{', '.join(memory.tags)}

---
*Memory stored in markdown format*
"""
        memory_file.write_text(content)

    def query_memories(
        self, tags: str = "", content_contains: str = ""
    ) -> List[Dict[str, Any]]:
        import re
        from datetime import datetime

        if not self.current_session:
            return []
        if not self.current_session.memories:
            self._load_session_memories(self.current_session.id)
        tag_filter_type = "any"
        if tags and ("&" in tags or "|" in tags):
            if "&" in tags:
                tag_list = [t.strip() for t in tags.split("&")]
                tag_filter_type = "all"
            else:
                tag_list = [t.strip() for t in tags.split("|")]
        elif tags:
            tag_list = [t.strip() for t in tags.split(",")]
        else:
            tag_list = []
        use_regex = False
        if (
            content_contains
            and content_contains.startswith("/")
            and content_contains.endswith("/")
            and len(content_contains) > 2
        ):
            use_regex = True
            regex_pattern = content_contains[1:-1]
            try:
                content_regex = re.compile(regex_pattern, re.IGNORECASE)
            except re.error:
                use_regex = False
        filtered_memories = []
        for memory in self.current_session.memories:
            if tag_list:
                if tag_filter_type == "all":
                    if not all(
                        any(tag.lower() in t.lower() for t in memory.tags)
                        for tag in tag_list
                    ):
                        continue
                elif not any(
                    any(tag.lower() in t.lower() for t in memory.tags)
                    for tag in tag_list
                ):
                    continue
            if content_contains:
                if use_regex:
                    if not content_regex.search(memory.content):
                        continue
                elif content_contains.lower() not in memory.content.lower():
                    continue
            memory_data = {
                "id": memory.id,
                "content": memory.content,
                "tags": memory.tags,
                "confidence": memory.confidence,
                "language": memory.language if memory.language else "",
                "has_code": bool(memory.code_snippet),
                "created_at": memory.created_at.isoformat(),
                "session_id": memory.session_id,
            }
            if len(memory.content) > 100:
                if content_contains and not use_regex:
                    pos = memory.content.lower().find(content_contains.lower())
                    if pos >= 0:
                        start = max(0, pos - 40)
                        end = min(len(memory.content), pos + len(content_contains) + 40)
                        excerpt = memory.content[start:end]
                        if start > 0:
                            excerpt = "..." + excerpt
                        if end < len(memory.content):
                            excerpt = excerpt + "..."
                        memory_data["excerpt"] = excerpt
                else:
                    memory_data["excerpt"] = memory.content[:100] + "..."
            filtered_memories.append(memory_data)
        return sorted(filtered_memories, key=lambda x: x["confidence"], reverse=True)

    def explore_packages(
        self, task_description: str, language: str = "python"
    ) -> List[str]:
        if not self.current_session:
            raise ValueError("No active session")
        installed_packages = []
        try:
            for dist in importlib.metadata.distributions():
                package_name = dist.metadata["name"]
                relevance_score = self._calculate_relevance(
                    package_name, task_description
                )
                if relevance_score > 0.3:
                    package = PackageInfo(
                        name=package_name,
                        version=dist.version,
                        description=f"Installed package: {package_name}",
                        relevance_score=relevance_score,
                        installation_status="installed",
                        session_id=self.current_session.id,
                    )
                    self.current_session.discovered_packages.append(package)
                    installed_packages.append(package_name)
        except Exception:
            pass
        self._save_session_to_file(self.current_session)
        return installed_packages

    def record_decision(
        self,
        decision_title: str,
        context: str,
        options_considered: str,
        chosen_option: str,
        rationale: str,
        consequences: str,
        package_dependencies: str = "",
    ) -> str:
        if not self.current_session:
            raise ValueError("No active session")
        decision = ArchitectureDecision(
            session_id=self.current_session.id,
            decision_title=decision_title,
            context=context,
            options_considered=options_considered,
            chosen_option=chosen_option,
            rationale=rationale,
            consequences=consequences,
            package_dependencies=(
                package_dependencies.split(",") if package_dependencies else []
            ),
        )
        self.current_session.architecture_decisions.append(decision)
        self._save_session_to_file(self.current_session)
        return decision.id

    def analyze_session(self) -> Dict[str, Any]:
        if not self.current_session:
            return {"error": "No active session"}
        return {
            "session_id": self.current_session.id,
            "session_type": self.current_session.session_type.value,
            "total_thoughts": len(self.current_session.thoughts),
            "total_memories": len(self.current_session.memories),
            "total_branches": len(self.current_session.branches),
            "architecture_decisions": len(self.current_session.architecture_decisions),
            "discovered_packages": len(self.current_session.discovered_packages),
            "created_at": self.current_session.created_at.isoformat(),
            "updated_at": self.current_session.updated_at.isoformat(),
        }

    def list_sessions(self) -> List[Dict[str, Any]]:
        sessions = []
        try:
            if self.index_file.exists():
                import re

                index_content = self.index_file.read_text()
                active_section = re.search(
                    "## Active Sessions\\n\\n(.*?)(?=\\n##|$)", index_content, re.DOTALL
                )
                if active_section:
                    active_entries = re.findall(
                        "- \\*\\*([\\w\\-]+)\\*\\*: (.*?) \\((\\w+), ([\\d\\-]+)\\)",
                        active_section.group(1),
                    )
                    for entry in active_entries:
                        session_id, problem, session_type, date = entry
                        session_file = self.sessions_dir / f"{session_id}.md"
                        if session_file.exists():
                            sessions.append(
                                {
                                    "id": session_id,
                                    "problem": problem,
                                    "type": session_type,
                                    "file": str(session_file),
                                    "created": session_file.stat().st_ctime,
                                }
                            )
            if not sessions:
                for session_file in self.sessions_dir.glob("*.md"):
                    session_id = session_file.stem
                    try:
                        content = session_file.read_text()
                        import re

                        problem_match = re.search("# (.*?)\\n", content)
                        problem = (
                            problem_match.group(1)
                            if problem_match
                            else "Unnamed session"
                        )
                        sessions.append(
                            {
                                "id": session_id,
                                "problem": problem,
                                "file": str(session_file),
                                "created": session_file.stat().st_ctime,
                            }
                        )
                    except Exception:
                        sessions.append(
                            {
                                "id": session_id,
                                "file": str(session_file),
                                "created": session_file.stat().st_ctime,
                            }
                        )
        except Exception:
            pass
        return sorted(sessions, key=lambda x: x["created"], reverse=True)

    def load_session(self, session_id: str) -> Dict[str, Any]:
        try:
            if not session_id or not session_id.strip():
                raise ValidationError("Session ID cannot be empty")

            session_file = self.sessions_dir / f"{session_id}.md"
            if not session_file.exists():
                raise SessionNotFoundError(f"Session {session_id} not found")

            content = session_file.read_text()
            session = self._parse_session_markdown(content, session_id)
            self.current_session = session
            self._load_session_memories(session_id)

            return {
                "session_id": session_id,
                "status": "loaded",
                "thoughts_count": len(session.thoughts),
                "memories_count": len(session.memories),
                "file": str(session_file),
            }

        except (ValidationError, SessionNotFoundError):
            raise
        except Exception as e:
            self.logger.error(f"Failed to load session {session_id}: {e}")
            raise SessionError(f"Could not load session {session_id}: {e}")

    def _suggest_packages(self, content: str) -> List[str]:
        suggestions = []
        keywords = {
            "http": ["requests", "httpx", "urllib3"],
            "web": ["flask", "django", "fastapi"],
            "data": ["pandas", "numpy", "sqlite3"],
            "test": ["pytest", "unittest", "mock"],
            "json": ["json", "jsonschema", "pydantic"],
            "async": ["asyncio", "aiohttp", "tornado"],
        }
        content_lower = content.lower()
        for keyword, packages in keywords.items():
            if keyword in content_lower:
                suggestions.extend(packages)
        return list(set(suggestions))

    def _calculate_relevance(self, package_name: str, task_description: str) -> float:
        task_lower = task_description.lower()
        package_lower = package_name.lower()
        if package_lower in task_lower:
            return 0.8
        common_words = set(task_lower.split()) & set(package_lower.split())
        if common_words:
            return 0.5
        return 0.1

    def _parse_session_markdown(self, content: str, session_id: str) -> UnifiedSession:
        import re
        from datetime import datetime

        session = UnifiedSession()
        session.id = session_id

        # Parse basic session metadata
        session_type_match = re.search("\\*\\*Type:\\*\\* (\\w+)", content)
        if session_type_match:
            session_type_value = session_type_match.group(1)
            session.session_type = (
                SessionType.CODING
                if session_type_value == "coding"
                else SessionType.GENERAL
            )

        created_match = re.search("\\*\\*Created:\\*\\* ([\\d\\-T:\\.]+)", content)
        if created_match:
            try:
                session.created_at = datetime.fromisoformat(created_match.group(1))
            except ValueError:
                pass

        updated_match = re.search("\\*\\*Updated:\\*\\* ([\\d\\-T:\\.]+)", content)
        if updated_match:
            try:
                session.updated_at = datetime.fromisoformat(updated_match.group(1))
            except ValueError:
                pass

        # Parse main sections
        problem_match = re.search(
            "## Problem Statement\\n(.*?)(?=\\n##)", content, re.DOTALL
        )
        if problem_match:
            session.problem = problem_match.group(1).strip()

        success_match = re.search(
            "## Success Criteria\\n(.*?)(?=\\n##)", content, re.DOTALL
        )
        if success_match:
            session.success_criteria = success_match.group(1).strip()

        constraints_match = re.search(
            "## Constraints\\n(.*?)(?=\\n##)", content, re.DOTALL
        )
        if constraints_match:
            session.constraints = constraints_match.group(1).strip()

        codebase_match = re.search(
            "## Codebase Context\\n(.*?)(?=\\n##)", content, re.DOTALL
        )
        if codebase_match:
            session.codebase_context = codebase_match.group(1).strip()

        # Parse thoughts with enhanced format
        thoughts_section = re.search(
            "## Thoughts.*?\\n\\n(.*)", content, re.DOTALL
        )
        if thoughts_section:
            # Find all thought blocks using a more direct approach
            thought_pattern = r"### Thought (\d+)(.*?)(?=### Thought \d+|\n##|$)"
            thought_matches = re.findall(thought_pattern, thoughts_section.group(1), re.DOTALL)

            for thought_num, block in thought_matches:
                # Extract ID
                id_match = re.search(r"\*\*ID:\*\* ([^\n]+)", block)
                # Extract confidence
                conf_match = re.search(r"\*\*Confidence:\*\* ([\d.]+)", block)
                # Extract content (between Created line and ---)
                content_match = re.search(r"\*\*Created:\*\* [^\n]+\n\n(.*?)(?=\n---|$)", block, re.DOTALL)

                if id_match and conf_match and content_match:
                    thought = Thought(
                        id=id_match.group(1).strip(),
                        session_id=session_id,
                        content=content_match.group(1).strip(),
                        confidence=float(conf_match.group(1)),
                    )
                    session.thoughts.append(thought)

        # Parse architecture decisions with enhanced format
        decisions_section = re.search(
            "## Architecture Decisions.*?\\n\\n(.*)", content, re.DOTALL
        )
        if decisions_section:
            # Find all decision blocks
            decision_pattern = r"### ([^\n]+)(.*?)(?=### [^\n]+\n\n|\n##|$)"
            decision_matches = re.findall(decision_pattern, decisions_section.group(1), re.DOTALL)

            for title, block in decision_matches:
                # Extract decision fields
                id_match = re.search(r"\*\*ID:\*\* ([^\n]+)", block)
                context_match = re.search(r"\*\*Context:\*\* ([^\n]+)", block)
                options_match = re.search(r"\*\*Options Considered:\*\* ([^\n]+)", block)
                chosen_match = re.search(r"\*\*Chosen Option:\*\* ([^\n]+)", block)
                rationale_match = re.search(r"\*\*Rationale:\*\* ([^\n]+)", block)
                consequences_match = re.search(r"\*\*Consequences:\*\* ([^\n]+)", block)
                packages_match = re.search(r"\*\*Package Dependencies:\*\* ([^\n]+)", block)

                if all([id_match, context_match, options_match, chosen_match, rationale_match, consequences_match]):
                    decision = ArchitectureDecision(
                        id=id_match.group(1).strip(),
                        session_id=session_id,
                        decision_title=title.strip(),
                        context=context_match.group(1).strip(),
                        options_considered=options_match.group(1).strip(),
                        chosen_option=chosen_match.group(1).strip(),
                        rationale=rationale_match.group(1).strip(),
                        consequences=consequences_match.group(1).strip(),
                        package_dependencies=packages_match.group(1).strip().split(", ") if packages_match and packages_match.group(1).strip() else [],
                    )
                    session.architecture_decisions.append(decision)

        # Parse discovered packages
        packages_section = re.search(
            "## Discovered Packages.*?\\n(.*?)(?=\\n##|$)", content, re.DOTALL
        )
        if packages_section:
            package_blocks = re.findall(
                "### ([^\\s]+) v([^\\n]+)\\n.*?\\*\\*Relevance Score:\\*\\* ([\\d.]+)\\n.*?\\*\\*Status:\\*\\* ([^\\n]+)",
                packages_section.group(1),
                re.DOTALL
            )
            for name, version, relevance, status in package_blocks:
                package = PackageInfo(
                    name=name.strip(),
                    version=version.strip(),
                    relevance_score=float(relevance),
                    installation_status=status.strip(),
                    session_id=session_id,
                )
                session.discovered_packages.append(package)

        return session

    def _load_session_memories(self, session_id: str) -> None:
        if not self.current_session:
            return
        memory_files = list(self.memories_dir.glob("*.md"))
        for memory_file in memory_files:
            content = memory_file.read_text()
            session_match = re.search("\\*\\*Session ID:\\*\\* ([\\w\\-]+)", content)
            if session_match and session_match.group(1) == session_id:
                memory_id = memory_file.stem
                memory_content_match = re.search(
                    "## Content\\n(.*?)(?=\\n##)", content, re.DOTALL
                )
                memory_content = (
                    memory_content_match.group(1).strip()
                    if memory_content_match
                    else ""
                )
                tags_match = re.search(
                    "## Tags\\n(.*?)(?=\\n##|\\n---)", content, re.DOTALL
                )
                tags = []
                if tags_match:
                    tags_text = tags_match.group(1).strip()
                    if tags_text:
                        tags = [tag.strip() for tag in tags_text.split(",")]
                memory = Memory(
                    id=memory_id,
                    session_id=session_id,
                    content=memory_content,
                    tags=tags,
                )
                code_match = re.search(
                    "## Code Snippet\\n```(\\w*)\\n(.*?)```", content, re.DOTALL
                )
                if code_match:
                    memory.language = code_match.group(1)
                    memory.code_snippet = code_match.group(2).strip()
                self.current_session.memories.append(memory)

    def _load_last_active_session(self) -> None:
        try:
            sessions = self.list_sessions()
            if sessions:
                latest_session_id = sessions[0]["id"]
                self.load_session(latest_session_id)
        except Exception:
            pass
